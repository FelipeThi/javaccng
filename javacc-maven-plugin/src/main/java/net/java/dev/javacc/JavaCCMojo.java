package net.java.dev.javacc;

import org.apache.maven.plugin.AbstractMojo;
import org.apache.maven.plugin.MojoExecutionException;
import org.apache.maven.project.MavenProject;
import org.codehaus.plexus.util.DirectoryScanner;

import java.io.File;
import java.util.Arrays;
import java.util.Collection;
import java.util.LinkedHashSet;

/**
 * Goal which runs JavaCC parser generator.
 *
 * @goal javacc
 * @phase generate-sources
 */
public class JavaCCMojo
    extends AbstractMojo {
  /**
   * The current Maven project.
   *
   * @parameter default-value="${project}"
   * @readonly
   * @required
   */
  private MavenProject project;
  /**
   * The directory where the JavaCC grammar files (<code>*.jj</code>) are located.
   *
   * @parameter expression="${sourceDirectory}" default-value="${basedir}/src/main/javacc"
   */
  private File sourceDirectory;
  /**
   * The directory where the parser files generated by JavaCC will be stored. The directory will be registered as a
   * compile source root of the project such that the generated files will participate in later build phases like
   * compiling and packaging.
   *
   * @parameter expression="${outputDirectory}" default-value="${project.build.directory}/generated-sources/javacc"
   */
  private File outputDirectory;
  /**
   * A set of Ant-like inclusion patterns used to select files from the source directory for processing. By default,
   * the pattern <code>**&#47;*.jj</code> is used to select grammar files.
   *
   * @parameter default-value="*.jj"
   */
  private String[] includes;
  /**
   * A set of Ant-like exclusion patterns used to prevent certain files from being processed. By default, this set is
   * empty such that no files are excluded.
   *
   * @parameter
   */
  private String[] excludes;

  public File getSourceDirectory() {
    return sourceDirectory;
  }

  public File getOutputDirectory() {
    return outputDirectory;
  }

  protected File[] getCompileSourceRoots() {
    return new File[]{getOutputDirectory()};
  }

  @Override
  public void execute()
      throws MojoExecutionException {
    File f = outputDirectory;

    if (!f.exists()) {
      f.mkdirs();
    }

    //

    Collection<File> compileSourceRoots = new LinkedHashSet<File>(Arrays.asList(getCompileSourceRoots()));
    for (File compileSourceRoot : compileSourceRoots) {
      addSourceRoot(compileSourceRoot);
    }
  }

  private void findGrammars() {
    if (!sourceDirectory.isDirectory()) {
      return;
    }
    DirectoryScanner scanner = new DirectoryScanner();
    scanner.setBasedir(sourceDirectory);
    scanner.setIncludes(includes);
    scanner.setExcludes(excludes);
    scanner.addDefaultExcludes();
    scanner.scan();
    for (String path : scanner.getIncludedFiles()) {
      //
    }
  }

  private void addSourceRoot(File path) {
    if (project != null) {
      getLog().debug("Adding compile source root: " + path);
      project.addCompileSourceRoot(path.getAbsolutePath());
    }
  }
}
