public class ScannerException extends RuntimeException {
  /** Lexical error occurred. */
  public static final int LEXICAL_ERROR = 0;

  /** Detected (and bailed out of) an infinite loop in the scanner. */
  public static final int LOOP_DETECTED = 1;

  private final int errorCode;
  private final int state;
#if KEEP_LINE_COLUMN
  private final int line;
  private final int column;
#fi
  private final int character;

  /**
   * Constructor with message and reason.
   *
   * @param message   Descriptive error message.
   * @param errorCode Reason for lexical error.
   */
  public ScannerException(String message, int errorCode) {
    super(message);
    this.errorCode = errorCode;
    this.state = -1;
#if KEEP_LINE_COLUMN
    this.line = -1;
    this.column = -1;
#fi
    this.character = 0;
  }

  /**
   * Create new lexical error instance.
   *
   * @param errorCode Reason for lexical error.
   * @param state     Lexical state in which this error occurred.
#if KEEP_LINE_COLUMN
   * @param line      Line number when the error occurred.
   * @param column    Column number when the error occurred.
#fi
#if KEEP_IMAGE
   * @param prefix    Prefix that was seen before this error occurred.
#fi
   * @param character The offending character, or -1 if EOF causes the error.
   */
#if KEEP_LINE_COLUMN
#if KEEP_IMAGE
  public ScannerException(int errorCode, int state, int line, int column, String prefix, int character) {
#else
  public ScannerException(int errorCode, int state, int line, int column, int character) {
#fi
#else
#if KEEP_IMAGE
  public ScannerException(int errorCode, int state, String prefix, int character) {
#else
  public ScannerException(int errorCode, int state, int character) {
#fi
#fi
#if KEEP_LINE_COLUMN
#if KEEP_IMAGE
    super(describe(state, line, column, prefix, character));
#else
    super(describe(state, line, column, character));
#fi
#else
#if KEEP_IMAGE
    super(describe(state, prefix, character));
#else
    super(describe(state, character));
#fi
#fi
    this.errorCode = errorCode;
    this.state = state;
#if KEEP_LINE_COLUMN
    this.line = line;
    this.column = column;
#fi
    this.character = character;
  }

  /** @return The reason why the exception is thrown. */
  public int getErrorCode() {
    return errorCode;
  }

  /** @return Lexical state in which this error occurred. */
  public int getState() {
    return state;
  }
#if KEEP_LINE_COLUMN

  /** @return Line number when the error occurred, 0-based. */
  public int getLine() {
    return line;
  }

  /** @return Column number when the error occurred, 0-based. */
  public int getColumn() {
    return column;
  }
#fi

  /** @return The offending character, or -1 if EOF causes the error. */
  public int getCharacter() {
    return character;
  }

  /**
   * Returns a detailed message for the exception when it is thrown by the
   * scanner to indicate a lexical error.
   *
   * @param state     Lexical state in which this error occurred.
#if KEEP_LINE_COLUMN
   * @param line      Line number when the error occurred.
   * @param column    Column number when the error occurred.
#fi
#if KEEP_IMAGE
   * @param prefix    Prefix that was seen before this error occurred.
#fi
   * @param character The offending character, or -1 if EOF causes the error.
   * @return Descriptive error message.
   */
#if KEEP_LINE_COLUMN
#if KEEP_IMAGE
  static String describe(int state, int line, int column, String prefix, int character) {
#else
  static String describe(int state, int line, int column, int character) {
#fi
#else
#if KEEP_IMAGE
  static String describe(int state, String prefix, int character) {
#else
  static String describe(int state, int character) {
#fi
#fi
    StringBuilder s = new StringBuilder();
#if KEEP_LINE_COLUMN
    s.append("Lexical error at line ").append(line + 1).append(", column ").append(column + 1)
        .append(". Encountered: ");
#else
    s.append("Lexical error")
        .append(". Encountered: ");
#fi
    if (character == -1) {
      s.append("<EOF>");
    }
    else {
      s.append("'");
      escape(s, String.valueOf((char) character));
      s.append("' (").append(character).append(")");
    }
#if KEEP_IMAGE
    s.append(" after: \"");
    escape(s, prefix);
    s.append("\"");
#fi
    return s.toString();
  }

  /**
   * Replaces unprintable characters by their escaped (or unicode escaped)
   * equivalents in the given string
   */
  static void escape(StringBuilder b, CharSequence cs) {
    for (int i = 0; i < cs.length(); i++) {
      char c = cs.charAt(i);
      switch (c) {
        case '\b':
          b.append("\\b");
          continue;
        case '\t':
          b.append("\\t");
          continue;
        case '\n':
          b.append("\\n");
          continue;
        case '\f':
          b.append("\\f");
          continue;
        case '\r':
          b.append("\\r");
          continue;
        case '\"':
          b.append("\\\"");
          continue;
        case '\'':
          b.append("\\\'");
          continue;
        case '\\':
          b.append("\\\\");
          continue;
        default:
          if (c < 0x20 || c > 0x7e) {
            b.append("\\u");
            String s = Integer.toString(c, 16);
            for (int n = 0; n < 4 - s.length(); n++) {
              b.append("0");
            }
            b.append(s);
          }
          else {
            b.append(c);
          }
          continue;
      }
    }
  }
}
