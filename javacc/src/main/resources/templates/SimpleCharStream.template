/**
 * An implementation of interface CharStream, where the stream is assumed to
 * contain only ASCII characters (without unicode processing).
 */
${SUPPORT_CLASS_VISIBILITY_PUBLIC?public :}final class SimpleCharStream implements CharStream {
  /** Reader that provides characters. */
  private final java.io.Reader reader;
  /** Buffer contains character of the token currently being read. */
  private char[] buffer;
  /** Number of token characters read so far. */
  private int length;
  /** Offset to the next character in the buffer, if backed up. */
  private int offset;
  /** Index of the first character of the current token, inclusive. */
  private int beginOffset;
  /** Index of the last character of the current token, exclusive. */
  private int endOffset;
#if KEEP_LINE_COLUMN
  /** Line number of the first character of the current token. */
  private int line = 1;
  /** Column number of the first character of the current token. */
  private int column = 1;
  /** Contains line numbers for read characters. */
  private int[] bufLine;
  /** Contains column numbers for read characters. */
  private int[] bufColumn;
  /** For line and column counting -- remembers if the last sequence is of CR LF chars. */
  private int state;
  /** Tab size. */
  private int tabSize = 8;
#fi

  /**
   * Create new character stream from the specified reader.
   *
   * @param reader A reader from which to read characters.
   */
  public SimpleCharStream(java.io.Reader reader) {
    this.reader = reader;
    buffer = new char[4096];
#if KEEP_LINE_COLUMN
    bufLine = new int[4096];
    bufColumn = new int[4096];
#fi
  }

  /**
   * Create new character stream from the specified reader.
   *
   * @param reader A reader from which to read characters.
   * @param offset An offset to start count from.
   */
  public SimpleCharStream(java.io.Reader reader, int offset) {
    this(reader);
    beginOffset = offset;
  }
#if KEEP_LINE_COLUMN

  /**
   * Create new character stream from the specified reader.
   *
   * @param reader      A reader from which to read characters.
   * @param startLine   A line number to start count from.
   * @param startColumn A column number to start count from.
   */
  public SimpleCharStream(java.io.Reader reader, int startLine, int startColumn) {
    this(reader);
    line = startLine;
    column = startColumn;
  }

  /**
   * Create new character stream from the specified reader.
   *
   * @param reader      A reader from which to read characters.
   * @param offset      An offset to start count from.
   * @param startLine   A line number to start count from.
   * @param startColumn A column number to start count from.
   */
  public SimpleCharStream(java.io.Reader reader, int offset, int startLine, int startColumn) {
    this(reader);
    beginOffset = offset;
    line = startLine;
    column = startColumn;
  }

  public void setTabSize(int i) {
    if (i < 0) {
      throw new IllegalArgumentException();
    }
    tabSize = i;
  }

  public int getTabSize(int i) {
    return tabSize;
  }
#fi

  public void beginToken() throws java.io.IOException {
    beginOffset = endOffset;
    if (offset == length) {
      // No backed up characters.
      length = 0;
      offset = 0;
    }
    else {
      // Preserve backed up characters.
      System.arraycopy(buffer, offset, buffer, 0, length - offset);
#if KEEP_LINE_COLUMN
      System.arraycopy(bufLine, offset, bufLine, 0, length - offset);
      System.arraycopy(bufColumn, offset, bufColumn, 0, length - offset);
#fi
      length = length - offset;
      offset = 0;
    }
  }

  public int readChar() throws java.io.IOException {
    if (offset < length) {
      // Read backed up characters.
      endOffset++;
      return buffer[offset++];
    }
    // Read new character by reader and put it into buffer.
    return read();
  }

  /**
   * Reads next character from the reader and appends it to the buffer of token chars.
   *
   * @return Character read from the reader.
   * @throws java.io.IOException If reader throws exception.
   */
  private int read() throws java.io.IOException {
    int c = reader.read();
    if (c != -1) {
      appendChar(c);
    }
    return c;
  }

  /**
   * Append character to the token buffer.
   *
   * @param c Character to append.
   */
  private void appendChar(int c) {
    endOffset++;
    if (offset == buffer.length) {
      int newLength = buffer.length * 3 / 2 + 1;
      buffer = copyOf(buffer, newLength);
#if KEEP_LINE_COLUMN
      bufLine = copyOf(bufLine, newLength);
      bufColumn = copyOf(bufColumn, newLength);
#fi
    }
#if KEEP_LINE_COLUMN
    updateLineColumn(c);
#fi
    buffer[offset++] = (char) c;
    length = offset;
  }

  /**
   * Truncate token buffer at the specified offset.
   *
   * @param c     Character to put at the specified index.
   * @param index New buffer length.
   */
  private void insertChar(int c, int index) {
    buffer[index] = (char) c;
    length = offset = index + 1;
  }

  public void backup(int amount) {
    endOffset -= amount;
    offset -= amount;
  }
#if KEEP_IMAGE

  public String getImage() {
    return new String(buffer, 0, offset);
  }

  public char[] getSuffix(int l) {
    char[] ret = new char[l];
    System.arraycopy(buffer, length - l, ret, 0, l);
    return ret;
  }
#fi
#if KEEP_LINE_COLUMN

  private void updateLineColumn(int c) {
    if (state == 1) {
      if (c == '\n') {
        state = 2;
        count(c);
        return;
      }
      else {
        wrap();
      }
    }
    else if (state == 3) {
      wrap();
    }
    else if (state == 2) {
      wrap();
    }

    count(c);

    if (c == '\r') {
      state = 1;
    }
    else if (c == '\n') {
      state = 3;
    }
    else {
      state = 0;
    }
  }

  private void count(int c) {
    bufLine[offset] = line;
    bufColumn[offset] = column;
    if (c == '\t') {
      column += tabSize - column % tabSize;
    }
    else {
      column++;
    }
  }

  private void wrap() {
    line += column = 1;
    bufLine[offset] = line;
    bufColumn[offset] = column;
  }
#fi

  public int getBeginOffset() {
    return beginOffset;
  }

  public int getEndOffset() {
    return endOffset;
  }
#if KEEP_LINE_COLUMN

  public int getBeginLine() {
    return bufLine[0];
  }

  public int getBeginColumn() {
    return bufColumn[0];
  }

  public int getEndLine() {
    if (offset > 0) {
      return bufLine[offset - 1];
    }
    return 0;
  }

  public int getEndColumn() {
    if (offset > 0) {
      return bufColumn[offset - 1];
    }
    return 0;
  }
#fi

  public void close() {
    buffer = null;
#if KEEP_LINE_COLUMN
    bufLine = null;
    bufColumn = null;
#fi
  }

  /** Backported from JDK6 Arrays.copyOf(...). */
  private static char[] copyOf(char[] original, int newLength) {
    char[] copy = new char[newLength];
    System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength));
    return copy;
  }

  /** Backported from JDK6 Arrays.copyOf(...). */
  private static int[] copyOf(int[] original, int newLength) {
    int[] copy = new int[newLength];
    System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength));
    return copy;
  }
}
