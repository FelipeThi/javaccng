/* Copyright (c) 2007, Paul Cager.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *     * Redistributions of source code must retain the above copyright notice,
 *       this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

package org.javacc.parser;

import org.javacc.Version;
import org.javacc.utils.io.IndentingPrintWriter;

import java.io.Closeable;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;

/**
 * This class handles the creation and maintenance of the boiler-plate classes,
 * such as Token.java, CharStream.java etc.
 *
 * It is responsible for:
 * <ul>
 * <li>Writing the JavaCC header lines to the file.</li>
 * <li>Writing the checksum line.</li>
 * <li>Using the checksum to determine if an existing file has been changed by
 * the user (and so should be left alone).</li>
 * <li>Checking any existing file's version (if the file can not be
 * overwritten).</li>
 * <li>Checking any existing file's creation options (if the file can not be
 * overwritten).</li>
 * </ul>
 *
 * @author Paul Cager
 */
public final class OutputFile implements Closeable {
  private static final String HEADER_LINE_1 = "/* Generated by: %s, Version: %s */";
  private static final String HEADER_LINE_2 = "/* Do not not edit this file. Your changes will be overwritten. */";
  private final File path;
  private ByteArrayOutputStream out;
  private AutoClosePrintWriter writer;

  public OutputFile(File path)
      throws IOException {
    this.path = path;

    if (path.exists()) {
      System.out.println("File \"" + path.getCanonicalPath()
          + "\" is being rebuilt.");
    }
    else {
      // File does not exist
      System.out.println("File \"" + path.getCanonicalPath()
          + "\" does not exist. Will create one.");
    }
  }

  /**
   * Return a PrintWriter object that may be used to write to this file. Any
   * necessary header information is written by this method.
   */
  public IndentingPrintWriter getPrintWriter() throws IOException {
    if (writer == null) {
      out = new ByteArrayOutputStream();
      writer = new AutoClosePrintWriter(out);

      // Write the headers....
      writer.printf(HEADER_LINE_1, Version.toolName, Version.versionNumber);
      writer.println();
      writer.printf(HEADER_LINE_2);
      writer.println();
    }
    return writer;
  }

  /**
   * Close the OutputFile, writing any necessary trailer information
   * (such as a checksum).
   */
  @Override
  public void close() throws IOException {
    // Write the trailer (checksum).
    if (writer != null) {
      writer.flush();
      writer.closeImpl();
      writer = null;

      out.commit(path);
      out = null;
    }
  }

  private class ByteArrayOutputStream extends java.io.ByteArrayOutputStream {
    ByteArrayOutputStream() {
      super(16384);
    }

    void commit(File path) throws IOException {
      File tmpPath = new File(path.getCanonicalPath() + ".tmp");
      try {
        try {
          write(tmpPath);
        }
        catch (IOException ex) {
          JavaCCErrors.semanticError("Could not write to file \"" + tmpPath.getCanonicalPath() + "\"");
          throw ex;
        }
        if (!tmpPath.renameTo(path)) {
          JavaCCErrors.semanticError("Could not overwrite file \"" + path.getCanonicalPath() + "\"");
          throw new IOException();
        }
      }
      finally {
        if (tmpPath.exists()) {
          if (!tmpPath.delete()) {
            tmpPath.deleteOnExit();
          }
        }
      }
    }

    private void write(File path) throws IOException {
      try {
        FileOutputStream out = new FileOutputStream(path);
        try {
          out.write(buf, 0, count);
        }
        finally {
          out.close();
        }
      }
      finally {
        buf = null;
      }
    }
  }

  private class AutoClosePrintWriter extends IndentingPrintWriter {
    private AutoClosePrintWriter(OutputStream os) {
      super(new OutputStreamWriter(os));
    }

    private void closeImpl() {
      super.close();
    }

    @Override
    public void close() {
      try {
        OutputFile.this.close();
      }
      catch (IOException ex) {
        System.err.println("Could not close \"" + path.getAbsolutePath() + "\"");
      }
    }
  }
}
